#!/usr/bin/env python

"""
Usage: sort-music [options]

Renames audio files based on metadata.

Options:
  -d DIRNAME, --directory=DIRNAME  Specify which directory to work in (default
                                   is the current directory).
  -f FORMAT, --format=FORMAT       Specify the naming format.
  -l, --flatten                    Move all files into the same root directory.
  -r, --recursive                  Work recursively on the specified directory.
  -t, --test                       Only display the new file names; nothing
                                   will be renamed.
  -h, --help                       Display this help.

Formatting:
  The following information is available to be used in the file name:
  album    artist    title    track

  To specify a file name format, enter the desired format enclosed in quotation
  marks. The words album, artist, title, and track will be replaced by values
  retrieved from the audio file's metadata.

  For example, --format="artist - album [track] title" will rename music files
  with the name format:
  Sample Artist - Sample Album [1] Sample Title

  The following characters are of special importance to the operating system
  and cannot be used in the file name:
  \    /    :    *    ?    "    <    >    |

  (=) is replaced by the directory path separator, so to move files into artist
  and album subdirectories, the following format can be used:
  "artist(=)album(=)track - title"

  If no format is provided, the default format is the same as used in the above
  example.

Examples:
  sort-music                       Renames music files in the current directory
  sort-music -d /music/path/       Renames music files in /music/path/
  sort-music -f "title -- artist"  Renames music files in the current directory
                                   with the name format:
                                   Sample Title -- Sample Artist.mp3
"""
import getopt
import mutagen.easyid3
import mutagen.oggvorbis
import os
import re
import sys
import time


class FormatError(Exception):
    """Exception raised due to improper formatting."""
    pass


class DirectoryError(Exception):
    """Exception raised due to a non-existent directory."""
    pass


def scan_directory(directory, file_ext_list, recursive=False):
    """
    Generate a list of files with the specified extension(s) in the specified
    directory (and its subdirectories, if the recursive option is enabled).
    """
    for dir_path, dummy, file_names in os.walk(directory):
        for name in file_names:
            # lower() is necessary here; otherwise ".MP3" is not considered a
            # valid extension and files will be skipped. The extension's case
            # is preserved when renaming the file, however.
            if os.path.splitext(name)[1].lower() in file_ext_list:
                yield os.path.normcase(os.path.join(dir_path, name))

        if not recursive:
            break  # do not continue to the next "dir_path"


class AudioFile:
    """A generic audio file."""
    def __init__(self, file_name):
        self.file_name = file_name
        self.file_ext = os.path.splitext(file_name)[1].lower()
        self.file_path = os.path.split(file_name)[0] + os.path.sep

        # Call the appropriate method based on the file type
        self.data = getattr(self, "parse_%s" % self.file_ext[1:])()

        self.generate()

    def generate(self):
        def lookup(key, default):
            return self.data[key][0] if (key in self.data and
                                         self.data[key][0]) else default

        self.artist = lookup('artist', "No Artist")
        self.album = lookup('album', "No Album")
        self.title = lookup('title', "No Title")
        self.track = lookup('tracknumber', '0')

        if self.track != '0':
            self.track = self.track.split('/')[0].lstrip('0')

        # In regards to track numbers, self.data["tracknumber"] returns numbers
        # in several different formats: 1, 1/10, 01, or 01/10. Wanting a
        # consistent format, the returned string is split at the "/" and
        # leading zeros are stripped.

    def parse_mp3(self):
        return mutagen.easyid3.EasyID3(self.file_name)

    def parse_ogg(self):
        return mutagen.oggvorbis.Open(self.file_name)

    def rename(self, new_file_name, flatten=False):
        def unique_name(new_file_name, count=0):
            """
            Returns a unique name if a file already exists with the supplied
            name.
            """
            c = "_(%s)" % str(count) if count else ""
            prefix = directory + os.path.sep if flatten else self.file_path
            test_file_name = prefix + new_file_name + c + self.file_ext

            if os.path.isfile(test_file_name):
                count += 1
                return unique_name(new_file_name, count)
            else:
                return test_file_name

        os.renames(self.file_name, unique_name(new_file_name))

        # Note: this function is quite simple at the moment; it does not
        # support multiple file extensions, such as "sample.txt.backup", which
        # would only retain the ".backup" file extension.

    def clean_file_name(self, format):
        """Generate a clean file name based on metadata."""
        raw_file_name = format % {'artist': self.artist,
                                  'album': self.album,
                                  'title': self.title,
                                  'track': self.track}

        # encode() is used to override the default encode error-handing mode;
        # which is to raise a UnicodeDecodeError
        raw_file_name.encode('ascii', 'replace')

        # Remove restricted filename characters (\, /, :, *, ?, ", <, >, |)
        # from the supplied string
        clean_file_name = re.sub(restricted_char_pattern, '+', raw_file_name)

        return clean_file_name.replace('(=)', os.path.sep)


def main(argv):
    global directory
    directory = os.getcwd()
    format = "%(artist)s - %(album)s [%(track)s] %(title)s"
    flatten = False
    recursive = False
    test = False

    def verify_format(format):
        """Verify the supplied filename format."""
        if re.search(restricted_char_pattern, format):
            raise FormatError("supplied format contains restricted characters")

        # The supplied format must contain at least one of "artist", "album",
        # "title", or "track", or all files will be named identically.
        if not re.search(format_pattern, format):
            raise FormatError("supplied format does not contain any metadata keys")

        format = format.replace('artist', "%(artist)s")
        format = format.replace('album', "%(album)s")
        format = format.replace('title', "%(title)s")
        format = format.replace('track', "%(track)s")
        return format

    def verify_directory(directory):
        """Verify the supplied directory path."""
        if os.path.isdir(directory):
            return os.path.abspath(directory)
        else:
            raise DirectoryError("supplied directory cannot be found")

    def usage():
        print(__doc__.strip())

    try:
        opts, args = getopt.getopt(argv, 'd:f:hlrt', ['directory=', 'format=',
                                                      'help', 'flatten',
                                                      'recursive', 'test'])
    except getopt.error as error:
        usage()
        print("\n***Error: %s***" % error)
        sys.exit(1)

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage()
            sys.exit()

        elif opt in ('-f', '--format'):
            try:
                format = verify_format(arg)

            except FormatError as error:
                print("\n***Error: %s***" % error)
                sys.exit(2)

        elif opt in ('-d', '--directory'):
            try:
                directory = verify_directory(arg)

            except DirectoryError as error:
                print("\n***Error: %s***" % error)
                sys.exit(3)

        elif opt in ('-l', '--flatten'):
            flatten = True

        elif opt in ('-r', '--recursive'):
            recursive = True

        elif opt in ('-t', '--test'):
            test = True

    work(directory, format, flatten, recursive, test)


def safety(message):
    print("\n***Attention: %s***" % message)
    safety = raw_input("Enter 'ok' to continue (any other response will abort): ")

    if safety.lower().strip() != 'ok':
        print("\n***Attention: aborting***")
        sys.exit()


def work(directory, format, flatten, recursive, test):
    file_list = list(scan_directory(directory, ['.mp3', '.ogg'], recursive))
    e = None

    try:
        if test:
            safety("testing mode; nothing will be renamed")
            print("\n***Attention: starting***")

            for f in file_list:
                e = f
                current = AudioFile(f)
                print(current.clean_file_name(format))

        else:
            count = 0
            total = len(file_list)
            safety("all audio files in %s will be renamed" % directory)

            print("\n***Attention: starting***")
            start = time.time()

            for f in file_list:
                e = f
                count += 1
                current = AudioFile(f)
                current.rename(current.clean_file_name(format), flatten)
                message = "Renamed %d of %d" % (count, total)
                sys.stdout.write("\r" + message)

            print("\n%d files renamed in %f seconds" % (len(file_list),
                                                        time.time() - start))
    except StandardError:
        print("\n***Error: %s***" % e)
        raise

if __name__ == '__main__':
    restricted_char_pattern = re.compile('[\\\\/:\*\?"<>\|]')
    format_pattern = re.compile('artist|album|title|track')
    main(sys.argv[1:])
